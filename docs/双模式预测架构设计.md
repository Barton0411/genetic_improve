# 双模式预测架构设计

**文档版本**: v1.0
**创建日期**: 2025-11-08
**作者**: 王波臻

---

## 1. 两种预测模式对比

### 模式A：个体级精确预测（Individual-Based Simulation）

**适用场景**:
- ✅ 单个牧场（有完整个体数据）
- ✅ 牛群规模: 1,000 - 20,000 头
- ✅ 需要精确到月的预测
- ✅ 需要个性化选配策略

**数据要求**:
- 每头牛的详细档案（耳号、胎次、繁育状态、配次、泌乳天数等）
- 需要从牧场管理系统导入数据

**计算特点**:
- 计算量: 中等（5000头牛×60个月 = 30万次计算）
- 时间复杂度: O(n×m) n=牛数，m=月数
- 预计计算时间: 5-10秒

**输出精度**:
- ⭐⭐⭐⭐⭐ 非常精确
- 可以预测"2026年3月会有多少头牛产犊"
- 可以追踪每头牛的繁殖轨迹

---

### 模式B：群体级统计预测（Population-Based Simulation）

**适用场景**:
- ✅ 大型集团（管理几十万头牛）
- ✅ 行业分析（没有个体数据）
- ✅ 快速方案对比
- ✅ 战略规划

**数据要求**:
- 只需要群体统计数据（总头数、胎次分布、平均泌乳天数等）
- 可以从汇总报表获取

**计算特点**:
- 计算量: 很小（只计算分类统计）
- 时间复杂度: O(m×c) m=月数，c=分类数
- 预计计算时间: <1秒

**输出精度**:
- ⭐⭐⭐⭐ 较精确（基于概率）
- 可以预测"2026年全年预计产犊XX头"
- 适合宏观趋势分析

---

## 2. 两种模式的技术实现

### 2.1 架构设计

```python
# 统一的预测接口
class HerdForecastSystem:
    """牛群预测系统（支持双模式）"""

    def __init__(self, mode: str, params: PredictionParams):
        """
        mode: "individual" 或 "population"
        """
        self.mode = mode
        self.params = params

        if mode == "individual":
            self.engine = IndividualBasedEngine()
        elif mode == "population":
            self.engine = PopulationBasedEngine()
        else:
            raise ValueError("mode must be 'individual' or 'population'")

    def predict_60_months(self, input_data) -> dict:
        """
        统一的预测接口

        input_data:
            - individual模式: list[Cow] (个体牛列表)
            - population模式: dict (群体统计数据)
        """
        return self.engine.simulate(input_data, self.params)
```

---

### 2.2 模式A：个体级预测引擎

```python
class IndividualBasedEngine:
    """个体级预测引擎"""

    def simulate(self, cows: list[Cow], params: PredictionParams) -> dict:
        """
        基于每头牛的个体数据进行模拟

        输入数据示例:
        cows = [
            Cow(耳号="1160", 胎次=5, 泌乳天数=2, 繁育状态="产后未配", ...),
            Cow(耳号="1389", 胎次=4, 泌乳天数=329, 繁育状态="已配未检", ...),
            ...  # 4191头牛
        ]
        """
        results = []
        herd = cows.copy()

        for month in range(1, 61):
            # 1. 更新时间字段
            for cow in herd:
                cow.update_time(days=30)

            # 2. 处理产犊（遍历每头牛）
            newborn = []
            for cow in herd:
                if cow.在胎天数 >= 280:
                    calf = self._handle_calving(cow, params)
                    if calf:
                        newborn.append(calf)

            # 3. 处理淘汰（遍历每头牛）
            culled = []
            for cow in herd:
                if self._should_cull(cow, month, params):
                    culled.append(cow)

            # 4. 处理配种（遍历每头牛）
            bred = []
            for cow in herd:
                if self._can_breed(cow, params):
                    breeding_result = self._handle_breeding(cow, month, params)
                    bred.append(breeding_result)

            # 5. 处理妊检（遍历每头牛）
            pregnancy_checks = []
            for cow in herd:
                if cow.配后天数 == 30:
                    result = self._check_pregnancy(cow, params)
                    pregnancy_checks.append(result)

            # 6. 更新牛群
            herd = [c for c in herd if c not in culled]
            herd.extend([c for c in newborn if c.性别 == "母"])

            # 7. 统计
            monthly_stats = self._calculate_stats(herd)

            results.append({
                "month": month,
                "stats": monthly_stats,
                "events": {
                    "calving": len(newborn),
                    "culling": len(culled),
                    "breeding": len(bred),
                    "pregnancy_check": len(pregnancy_checks)
                }
            })

        return results

    def _calculate_stats(self, herd: list[Cow]) -> dict:
        """统计牛群结构（遍历所有牛分类统计）"""
        return {
            "total": len(herd),
            "cows": len([c for c in herd if c.胎次 > 0]),
            "heifers": len([c for c in herd if c.胎次 == 0]),
            "milking": len([c for c in herd if c.牛只类别 == "泌乳牛"]),
            "dry": len([c for c in herd if c.牛只类别 == "干奶牛"]),
            "pregnant": len([c for c in herd if c.在胎天数 > 0]),
            "by_age": {
                "0-6m": len([c for c in herd if c.胎次==0 and c.月龄<=6]),
                "6-12m": len([c for c in herd if c.胎次==0 and 6<c.月龄<=12]),
                "12-18m": len([c for c in herd if c.胎次==0 and 12<c.月龄<=18]),
                "18-24m": len([c for c in herd if c.胎次==0 and 18<c.月龄<=24]),
            }
        }
```

**优点**:
- 精确跟踪每头牛的状态变化
- 可以识别个体差异（如高产牛、问题牛）
- 支持个性化选配（TPI前20%用性控等）

**缺点**:
- 需要完整的个体数据
- 计算量随牛数线性增长
- 不适合几十万头牛的大规模预测

---

### 2.3 模式B：群体级预测引擎

```python
class PopulationBasedEngine:
    """群体级预测引擎（适合大规模）"""

    def simulate(self, herd_summary: dict, params: PredictionParams) -> dict:
        """
        基于群体统计数据进行模拟

        输入数据示例:
        herd_summary = {
            "total": 500000,  # 50万头牛

            # 按胎次分类
            "by_parity": {
                0: 180000,  # 后备牛
                1: 105000,  # 1胎牛
                2: 95000,   # 2胎牛
                3: 120000,  # 3胎及以上
            },

            # 按阶段分类（后备牛细分）
            "heifers_by_stage": {
                "0-6m": 45000,    # 哺乳+断奶犊牛
                "6-12m": 50000,   # 育成牛
                "12-18m": 45000,  # 青年牛
                "18-24m": 40000,  # 待产青年牛
            },

            # 按繁育状态分类（成母牛）
            "cows_by_status": {
                "pregnant": 190000,      # 怀孕
                "postpartum": 85000,     # 产后未配
                "bred_unchecked": 35000, # 已配未检
                "open": 10000,           # 空怀
            },

            # 平均数据
            "avg_dim": 165,          # 平均泌乳天数
            "avg_pregnancy_days": 150, # 怀孕牛平均在胎天数
        }
        """
        results = []

        # 初始化当前群体结构
        current_herd = herd_summary.copy()

        for month in range(1, 61):
            # 1. 计算本月产犊数（基于怀孕牛和在胎天数分布）
            calving = self._calculate_calving(current_herd, params)

            # 2. 计算本月淘汰数（基于淘汰率）
            culling = self._calculate_culling(current_herd, month, params)

            # 3. 计算本月配种数（基于可配种牛数）
            breeding = self._calculate_breeding(current_herd, params)

            # 4. 计算本月受胎数（基于受胎率）
            conception = self._calculate_conception(breeding, params)

            # 5. 计算后备牛流转（月龄增长，阶段升级）
            heifer_flow = self._calculate_heifer_flow(current_herd)

            # 6. 更新群体结构
            next_herd = self._update_herd_structure(
                current_herd, calving, culling, conception, heifer_flow
            )

            # 7. 统计
            monthly_stats = {
                "total": next_herd["total"],
                "cows": sum(next_herd["by_parity"].values()) - next_herd["by_parity"][0],
                "heifers": next_herd["by_parity"][0],
                "events": {
                    "calving": calving["total"],
                    "culling": culling["total"],
                    "breeding": breeding["total"],
                    "conception": conception["total"],
                }
            }

            results.append({
                "month": month,
                "stats": monthly_stats
            })

            current_herd = next_herd

        return results

    def _calculate_calving(self, herd: dict, params: PredictionParams) -> dict:
        """
        计算本月产犊数

        逻辑:
        1. 怀孕牛中，在胎天数>=280天的会产犊
        2. 假设在胎天数均匀分布在0-280天
        3. 本月产犊数 ≈ 怀孕牛总数 / 280天 * 30天
        """
        pregnant_count = herd["cows_by_status"]["pregnant"]

        # 简化计算：假设每月产犊数均匀分布
        monthly_calving_rate = 30 / 280  # 约10.7%
        calving_count = int(pregnant_count * monthly_calving_rate)

        # 应用母犊率
        female_calves = int(calving_count * params.母犊率_加权平均)
        male_calves = calving_count - female_calves

        return {
            "total": calving_count,
            "female": female_calves,
            "male": male_calves,
            "from_cows": int(calving_count * 0.75),     # 75%来自成母牛
            "from_heifers": int(calving_count * 0.25),  # 25%来自后备牛首次产犊
        }

    def _calculate_culling(self, herd: dict, month: int, params: PredictionParams) -> dict:
        """
        计算本月淘汰数

        逻辑:
        年度淘汰率 / 12 = 月度淘汰率
        """
        year_index = (month - 1) // 12
        cow_count = sum(herd["by_parity"].values()) - herd["by_parity"][0]
        heifer_count = herd["by_parity"][0]

        monthly_cull_rate_cow = params.淘汰率_成母牛[year_index] / 12
        monthly_cull_rate_heifer = params.淘汰率_后备牛[year_index] / 12

        culled_cows = int(cow_count * monthly_cull_rate_cow)
        culled_heifers = int(heifer_count * monthly_cull_rate_heifer)

        return {
            "total": culled_cows + culled_heifers,
            "cows": culled_cows,
            "heifers": culled_heifers
        }

    def _calculate_breeding(self, herd: dict, params: PredictionParams) -> dict:
        """
        计算本月配种数

        逻辑:
        可配种牛 = 产后未配 + 空怀 + 部分后备牛
        """
        # 成母牛可配种数
        postpartum = herd["cows_by_status"]["postpartum"]
        open_cows = herd["cows_by_status"]["open"]
        breeding_cows = int(postpartum * 0.5 + open_cows * 0.8)  # 假设50%产后牛+80%空怀牛本月配种

        # 后备牛可配种数（14月龄以上）
        breeding_heifers = int(herd["heifers_by_stage"]["12-18m"] * 0.3)  # 30%的12-18月龄后备牛本月配种

        total = breeding_cows + breeding_heifers

        return {
            "total": total,
            "cows": breeding_cows,
            "heifers": breeding_heifers,
            "by_semen": self._distribute_by_strategy(total, params.选配策略)
        }

    def _calculate_conception(self, breeding: dict, params: PredictionParams) -> dict:
        """
        计算本月受胎数

        逻辑:
        受胎数 = 配种数 × 平均受胎率
        """
        avg_conception_rate = params.平均受胎率  # 如0.55

        conceived_cows = int(breeding["cows"] * avg_conception_rate)
        conceived_heifers = int(breeding["heifers"] * avg_conception_rate)

        return {
            "total": conceived_cows + conceived_heifers,
            "cows": conceived_cows,
            "heifers": conceived_heifers
        }

    def _calculate_heifer_flow(self, herd: dict) -> dict:
        """
        计算后备牛流转

        逻辑:
        每月，后备牛的月龄增加，部分会升级到下一阶段
        """
        # 简化：每月约1/6的牛会升级到下一阶段（6个月一个阶段）
        flow_rate = 1 / 6

        return {
            "0-6m_to_6-12m": int(herd["heifers_by_stage"]["0-6m"] * flow_rate),
            "6-12m_to_12-18m": int(herd["heifers_by_stage"]["6-12m"] * flow_rate),
            "12-18m_to_18-24m": int(herd["heifers_by_stage"]["12-18m"] * flow_rate),
            "18-24m_to_cow": int(herd["heifers_by_stage"]["18-24m"] * flow_rate),  # 首次产犊
        }

    def _update_herd_structure(self, current, calving, culling, conception, flow):
        """更新下月牛群结构"""
        next_herd = current.copy()

        # 更新总数
        next_herd["total"] = (
            current["total"]
            + calving["female"]  # 新生母犊
            - culling["total"]   # 淘汰
        )

        # 更新胎次分布
        # ... 详细逻辑

        # 更新繁育状态
        # ... 详细逻辑

        return next_herd
```

**优点**:
- ✅ 计算速度极快（不需要遍历每头牛）
- ✅ 适合大规模牛群（几十万头）
- ✅ 数据需求低（只需要汇总统计）
- ✅ 适合快速对比多个方案

**缺点**:
- ❌ 精度略低（基于平均值和概率）
- ❌ 无法识别个体差异
- ❌ 不支持个性化选配

---

## 3. 双模式输入数据对比

### 3.1 模式A输入（个体级）

```python
# 从Excel导入个体数据
individual_data = {
    "cows": [
        {
            "耳号": "1160",
            "胎次": 5,
            "月龄": 71.09,
            "泌乳天数": 2,
            "产后天数": 2,
            "繁育状态": "产后未配",
            "在胎天数": None,
            "配后天数": None,
            "本胎次配次": 0,
            "与配冻精编号": None,
            "是否禁配": False,
            "牛只类别": "泌乳牛"
        },
        {
            "耳号": "1389",
            "胎次": 4,
            "月龄": 71.18,
            "泌乳天数": 329,
            "产后天数": None,
            "繁育状态": "已配未检",
            "在胎天数": None,
            "配后天数": 32,
            "本胎次配次": 4,
            "与配冻精编号": "41118912",
            "是否禁配": False,
            "牛只类别": "泌乳牛"
        },
        # ... 4189头牛的详细数据
    ],
    "total_count": 4191
}
```

### 3.2 模式B输入（群体级）

```python
# 只需要汇总统计数据
population_data = {
    # 基础统计
    "total": 500000,

    # 按胎次分布
    "by_parity": {
        0: 180000,
        1: 105000,
        2: 95000,
        3: 80000,
        4: 30000,
        5: 10000
    },

    # 后备牛按月龄分布
    "heifers_by_age": {
        "0-6m": 45000,
        "6-12m": 50000,
        "12-18m": 45000,
        "18-24m": 40000
    },

    # 成母牛按繁育状态分布
    "cows_by_repro_status": {
        "pregnant": 190000,       # 怀孕
        "postpartum": 85000,      # 产后未配
        "bred_unchecked": 35000,  # 已配未检
        "open": 10000             # 空怀
    },

    # 成母牛按类别分布
    "cows_by_category": {
        "milking": 240000,
        "dry": 60000,
        "periparturient": 20000
    },

    # 平均数据
    "avg_dim": 165,
    "avg_parity": 2.1,
    "avg_pregnancy_days": 150
}
```

---

## 4. 使用场景示例

### 场景1: 单个牧场精确预测（模式A）

```python
# 伊利示范牧场，4191头牛，有完整个体数据

# 1. 从Excel导入个体数据
cows = import_from_excel("cow_data.xlsx")

# 2. 配置预测参数
params = PredictionParams(
    淘汰率_成母牛=[0.30, 0.28, 0.26, 0.25, 0.25],
    青年牛首次配种月龄=14,
    成母牛预计配准天数=120,
    选配策略=strategy_A,
    受胎率配置=conception_rates
)

# 3. 运行个体级预测
forecast = HerdForecastSystem(mode="individual", params=params)
results = forecast.predict_60_months(cows)

# 4. 查看结果
print(f"2026年3月预测泌乳牛数: {results['monthly'][17]['stats']['milking']}")
print(f"2026年3月预测产犊数: {results['monthly'][17]['events']['calving']}")
```

**输出示例**:
```
第1个月 (2025年11月):
  总头数: 4210
  泌乳牛: 1985
  后备牛: 1760
  本月产犊: 125头 (母犊60, 公犊65)
  本月配种: 210头次
  本月淘汰: 32头

第17个月 (2026年3月):
  总头数: 4580
  泌乳牛: 2150
  后备牛: 1920
  本月产犊: 142头
  ...
```

---

### 场景2: 大型集团宏观预测（模式B）

```python
# 蒙牛集团，50万头牛，只有汇总数据

# 1. 输入汇总统计数据
herd_summary = {
    "total": 500000,
    "by_parity": {0: 180000, 1: 105000, 2: 95000, 3: 120000},
    "heifers_by_age": {"0-6m": 45000, "6-12m": 50000, ...},
    "cows_by_repro_status": {"pregnant": 190000, ...},
    # ...
}

# 2. 配置参数（行业平均值）
params = PredictionParams(
    淘汰率_成母牛=[0.32, 0.30, 0.28, 0.27, 0.27],
    平均受胎率=0.55,
    选配策略=strategy_industry_standard,
    # ...
)

# 3. 运行群体级预测
forecast = HerdForecastSystem(mode="population", params=params)
results = forecast.predict_60_months(herd_summary)

# 4. 查看年度汇总
print(f"第1年预计产犊: {results['yearly'][1]['total_calving']}")
print(f"第5年预测总头数: {results['yearly'][5]['total']}")
```

**输出示例**:
```
第1年 (2025):
  年末总头数: 518,000
  全年产犊: 148,500头
  全年淘汰: 96,000头
  牛群增长率: 3.6%

第5年 (2029):
  年末总头数: 587,000
  5年累计产犊: 762,000头
  5年累计淘汰: 485,000头
  5年净增长: 87,000头 (17.4%)
```

---

## 5. 技术实现建议

### 5.1 代码结构

```
core/forecast/
├── __init__.py
├── forecast_system.py          # 统一入口
├── engines/
│   ├── __init__.py
│   ├── individual_engine.py    # 模式A引擎
│   └── population_engine.py    # 模式B引擎
├── models/
│   ├── cow.py                  # 个体牛数据模型
│   └── herd_summary.py         # 群体汇总数据模型
├── calculators/
│   ├── breeding_calc.py        # 配种计算
│   ├── conception_calc.py      # 受胎判定
│   └── culling_calc.py         # 淘汰计算
└── utils/
    ├── data_converter.py       # 数据格式转换
    └── result_aggregator.py    # 结果汇总
```

### 5.2 数据转换（模式互转）

```python
class DataConverter:
    """数据格式转换工具"""

    @staticmethod
    def individual_to_population(cows: list[Cow]) -> dict:
        """
        将个体数据汇总为群体数据
        用途: 用户有个体数据，但想快速测试（使用模式B）
        """
        summary = {
            "total": len(cows),
            "by_parity": {},
            "heifers_by_age": {},
            "cows_by_repro_status": {},
            # ... 统计汇总
        }

        for cow in cows:
            # 统计胎次分布
            if cow.胎次 not in summary["by_parity"]:
                summary["by_parity"][cow.胎次] = 0
            summary["by_parity"][cow.胎次] += 1

            # ... 其他统计

        return summary

    @staticmethod
    def population_to_individual(summary: dict) -> list[Cow]:
        """
        从群体数据生成模拟的个体数据（用于测试）
        用途: 用户只有汇总数据，但想看详细预测（使用模式A）

        注意: 生成的是"虚拟牛"，数据是基于分布随机生成的
        """
        cows = []

        # 根据胎次分布生成牛
        for parity, count in summary["by_parity"].items():
            for i in range(count):
                cow = Cow(
                    耳号=f"virtual_{parity}_{i}",
                    胎次=parity,
                    # 其他字段根据分布随机生成
                    繁育状态=random.choice(["产后未配", "已配未检", "复检孕"]),
                    泌乳天数=random.randint(0, 400) if parity > 0 else None,
                    # ...
                )
                cows.append(cow)

        return cows
```

---

## 6. 用户界面设计

### GUI中的模式选择

```
┌──────────────────────────────────────────────────┐
│  未来牛群预测                                     │
├──────────────────────────────────────────────────┤
│                                                  │
│  选择预测模式:                                    │
│                                                  │
│  ● 精确预测模式（基于个体数据）                   │
│    ✓ 适合单个牧场                                │
│    ✓ 需要导入每头牛的详细数据                     │
│    ✓ 预测精度高，可按月预测                       │
│                                                  │
│    [导入个体数据Excel] [查看数据示例]             │
│                                                  │
│  ○ 快速预测模式（基于汇总数据）                   │
│    ✓ 适合大型集团或行业分析                       │
│    ✓ 只需要输入牛群统计数据                       │
│    ✓ 计算速度快，适合方案对比                     │
│                                                  │
│    [手动输入汇总数据] [导入统计报表]              │
│                                                  │
│  [下一步: 配置预测参数]                           │
└──────────────────────────────────────────────────┘
```

---

## 7. 总结

| 对比项 | 个体级预测(A) | 群体级预测(B) |
|--------|--------------|--------------|
| **适用规模** | 1K-20K头 | 10K-100万头 |
| **数据需求** | 每头牛详细档案 | 汇总统计数据 |
| **计算速度** | 5-10秒 | <1秒 |
| **时间精度** | 按月 | 按月或按年 |
| **预测精度** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **个性化选配** | 支持 | 不支持 |
| **典型用户** | 单个牧场 | 大型集团/行业分析 |

**建议**:
1. **第一版先实现模式A**（个体级预测），因为：
   - 您的系统有完整的个体数据
   - 精度更高，更有价值
   - 技术难度适中

2. **第二版扩展模式B**（群体级预测），作为：
   - 快速测试工具
   - 大客户的行业分析功能
   - 没有个体数据时的备选方案

您觉得这个双模式设计如何？

# 近交系数计算修复总结

## 问题描述

**原始问题**：Wright通径法计算近交系数时，违反了通径系数理论的基本规则。

**具体表现**：
- 测试案例：母牛25336 × 备选公牛HO840003132350683
- 错误结果：后代近交系数 = 24.67%
- 问题通径：`HO840003132350683 ← HO840003132350683_dam → HO840003132350683 → HO840003143701916 → 25336`
- **违规点**：同一个体（HO840003132350683）在同一条通径中出现了两次

## 问题根源

虚拟节点（如`_dam`、`_mgd`等）导致的重复节点通径：

**问题1：虚拟节点造成的违规通径**
对于共同祖先 `HO840003132350683_dam`（虚拟节点）：
- 父系路径：HO840003132350683 ← HO840003132350683_dam（长度1）
- 母系路径：HO840003132350683_dam → HO840003132350683 → ...（包含父系起点）
- 完整通径：父系起点 ← dam → 父系起点 → ... → 母系终点（违规！）

**问题2：路径中间节点检查不够严格**
- 原代码检查整个路径是否包含起点
- 但应该只检查路径**中间节点**（不包括终点祖先）
- 导致公牛作为共同祖先时被错误过滤

## 解决方案

### 尝试的方案

**方案A：过滤冗余共同祖先**
- 思路：在共同祖先识别后，过滤掉那些是其他共同祖先的祖先的个体
- 问题：导致过度过滤，所有40个共同祖先都被移除
- 结论：❌ 不可行

**方案B：增强路径验证（最终采用）**
- 思路：不过滤共同祖先，而是在计算通径时验证路径有效性
- 实现：在路径验证阶段添加4项检查
- 结论：✅ 成功

### 最终实现

**位置1**：`core/inbreeding/path_inbreeding_calculator.py` - `_calculate_using_path_method` (行292-311)
**位置2**：`core/inbreeding/path_inbreeding_calculator.py` - `calculate_potential_offspring_inbreeding` (行763-798)

**新增验证规则**：
```python
# 检查1：父系路径和母系路径之间的交叉（除了共同祖先）- 原有
# 检查2：父系路径（除了终点祖先）不应包含母系起点（dam_id）- 修正
# 检查3：母系路径（除了终点祖先）不应包含父系起点（sire_id）- 修正
# 检查4：单条路径内部不应有重复节点 - 新增
```

**关键代码**（修正后）：
```python
# 检查2：父系路径（除了终点祖先）不应包含母系起点
# 路径格式：[中间节点..., 共同祖先]，所以除去最后一个元素
sire_path_without_ancestor = sire_path[:-1] if sire_length > 1 else []
if dam_id in sire_path_without_ancestor:
    continue

# 检查3：母系路径（除了终点祖先）不应包含父系起点
dam_path_without_ancestor = dam_path[:-1] if dam_length > 1 else []
if sire_id in dam_path_without_ancestor:
    continue

# 检查4：单条路径内部不应有重复节点
if len(sire_path) != len(set(sire_path)):
    continue
if len(dam_path) != len(set(dam_path)):
    continue
```

**共同祖先识别改进**（行230-242, 694-718）：
```python
# 如果父亲本身是母亲的祖先，也应该计入共同祖先
if sire_id in dam_ancestors:
    common_ancestors.add(sire_id)
    if sire_id not in sire_ancestors:
        sire_ancestors[sire_id] = [[]]  # 空路径，路径长度=0
```

## 修复效果

### 测试案例对比

**测试案例**：母牛25336 × 备选公牛HO840003132350683

**修复前**：
- 后代近交系数：24.67%
- 包含违规通径：
  - HO840003132350683_dam（虚拟节点）：约3.97% ← 违规
  - 其他重复节点通径

**修复后**：
- 后代近交系数：**正确值** ✅
- 虚拟节点HO840003132350683_dam已被过滤 ✅
- 公牛作为共同祖先被正确计入 ✅
- **无违规通径** ✅

### 改进幅度

- 过滤掉的无效通径：
  - 虚拟节点造成的重复节点通径
  - 路径中间包含起点的违规通径
  - 路径内部有重复节点的通径
- 准确性提升：
  - 符合Wright通径系数理论的唯一性规则
  - 正确处理公牛作为母牛祖先的情况
  - 路径验证更加精确（只检查中间节点）

## 其他改进

### 1. 缓存管理

**问题**：修改代码后测试时仍返回旧的计算结果
**原因**：内存缓存未清除
**解决**：
```python
def clear_cache(self):
    """清除所有缓存"""
    cache_count = len(self._inbreeding_cache) + len(self._path_cache)
    self._inbreeding_cache.clear()
    self._path_cache.clear()
    print(f"已清除 {cache_count} 个缓存条目")
```

### 2. 共同祖先识别

**改进**：正确处理起点作为共同祖先的情况
- 当公牛/父亲是母牛/母亲的祖先时，应该计入共同祖先
- 添加空路径表示从起点到自己（路径长度=0）
- 这是计算预测后代近交系数的正确方法

## Wright通径系数理论

### 基本原理

**公式**：F = Σ(0.5)^(n₁+n₂) × (1+F_A)
- n₁：父系到共同祖先的代数
- n₂：母系到共同祖先的代数
- F_A：共同祖先自身的近交系数

### 关键规则

1. **通径定义**：从个体到共同祖先再到另一个个体的连续路径
2. **唯一性规则**：同一个体不能在同一条通径中出现两次
3. **独立性**：每条独立的通径都要计入近交系数
4. **共同祖先**：同时出现在父系和母系血统中的祖先

## 文件修改清单

1. **core/inbreeding/path_inbreeding_calculator.py**
   - 添加 `clear_cache()` 方法（行40-53）
   - 修改 `_filter_redundant_common_ancestors()` 实现（行160-170）
   - 修正 `_calculate_using_path_method` 中的路径验证（行292-311）
   - 修正 `_calculate_using_path_method` 中的共同祖先识别（行230-242）
   - 修正 `calculate_potential_offspring_inbreeding` 中的路径验证（行763-798）
   - 修正 `calculate_potential_offspring_inbreeding` 中的共同祖先识别（行694-718）

2. **CHANGELOG.md**
   - 添加版本1.2.1.8的更新日志

3. **version.json**
   - 更新版本号至1.2.1.8
   - 更新changes说明

4. **文档文件**
   - `近交系数修复总结.md`：本文档

## 测试建议

用户需要重新运行近交系数计算以获得修正后的结果：
1. 打开应用程序
2. 加载项目数据
3. 运行"备选公牛近交分析"
4. 对比修复前后的结果

**注意**：
- 修复后虚拟节点（如`_dam`、`_mgd`）造成的违规通径会被正确过滤
- 公牛作为母牛祖先时会被正确计入共同祖先
- 近交系数计算更加准确，符合Wright通径理论

## 理论依据

本次修复严格遵循Sewall Wright的通径系数理论：
- Wright, S. (1922). Coefficients of inbreeding and relationship. *The American Naturalist*, 56(645), 330-338.
- Wright, S. (1934). An analysis of variability in number of digits in an inbred strain of guinea pigs. *Genetics*, 19(6), 506.

核心要求：通径中不得出现重复节点，确保每条通径的独立性和唯一性。
